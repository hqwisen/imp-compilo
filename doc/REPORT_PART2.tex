\documentclass[letterpaper]{article}
\usepackage{natbib}
\usepackage[utf8]{inputenc}
%\usepackage[margin=1in]{geometry}
\usepackage{geometry}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{graphicx}%images
\usepackage{fancyhdr}%for headers and footers

\usepackage{xcolor}
\usepackage{adjustbox}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{fancyhdr}

\usepackage{multirow}
\usepackage{amsmath}
\usepackage{array}

% ------ HEADERS AND FOOTERS -----------
% \lhead{INFO-F403}
% \rhead{Project Report - Part 1}
\pagestyle{fancy}
\rfoot{\thepage}
\cfoot{}
%\lfoot{Academic Year 2017-18}

\begin{document}
\begin{titlepage}
\begin{center}


\textsc{\LARGE universit\'e libre de bruxelles}\\[1.0cm]
\textsc{\Large D\'epartment d'Informatique}\\[1.5cm]

% Upper part of the page. The '~' is needed because \\
% only works if a paragraph has started.
\includegraphics[width=0.2\textwidth]{image/ulblogo.jpg}~\\[1cm]

\textsc{\Large INFO-F403 - Introduction to language theory and compiling
\\[0.3cm]}
% Title
% \HRule \\[0.4cm]
{ \huge \bfseries Project Report â€“ Part 2  \\[0.4cm] }

%\HRule \\[1.5cm]

% Author and supervisor
\noindent
\begin{center} \large

\emph{Author:}\\
Hakim \textsc{Boulahya}\\
\end{center}
\begin{center} \large

\emph{Professor:} \\
Gilles \textsc{Geeraerts}\\

\end{center}

\vfill

% Bottom of the page
{\large \today}

\end{center}
\end{titlepage}

\tableofcontents
\newpage

\section{Grammar}

\subsection{Unproductive and unreachable symbols (a)}

In the given grammar, there is no unproductive and/or unreachable symbols.

\subsection{Priority and associativity of the operators (b)}

\paragraph{Note} In this section, P\&A refers to priority and associativity
of the operators, AE to arithmetic expression and BE to boolean expression.

\subsubsection{Arithmetic expressions}

\paragraph{}

Since an arithmetic expression must always be process first before bing compared
to another one in a boolean expression, we will consider those two separatly.

\paragraph{}

First let's consider the P\&A of the arithmetic expressions. We have the
following P\&A:

\begin{tabular}{|c|c|}
    \hline
    - & right \\
    \hline
    *, / & left \\
    \hline
    +, - & left \\
    \hline
\end{tabular}

 And the following grammar:
    \begin{center}
            \begin{tabular}{l l}
                $<$ExprArith$>$ &$\rightarrow$ [VarName] \\
                 &$\rightarrow$ [Number] \\
                 &$\rightarrow$ ($<$ExprArith$>$) \\
                 &$\rightarrow$ - $<$ExprArith$>$ \\
                 &$\rightarrow$
                $<$ExprArith$>$ $<$Op$>$ $<$ExprArith$>$ \\
                $<$Op$>$ &$\rightarrow$ $+$ \\
                 &$\rightarrow$ $-$ \\
                 &$\rightarrow$ $*$ \\
                 &$\rightarrow$ $/$ \\
            \end{tabular}
    \end{center}


As mention in the course page 111, an AE must be a \textit{sum of products},
more specifically in our case a \textit{\{sum, substraction\}
of \{produts, division\}}. We will use the same atom definition in the course,
with \texttt{Number} as the constant rule and \texttt{VarName} as the id rule.
The minus operator as a right associativity, meaning that it is always linked
to the atom next to the operator, so we will set this operator directly as
an atom rule.

Same thing goes for the parenthesis. The must be handled without considering
the operators outside the parenthesis, so as an atom.

We have the following grammar results:


    \begin{center}
            \begin{tabular}{l l}
                $<$ExprArith$>$ &$\rightarrow$
                $<$ExprArith$>$ $<$SumSubOp$>$ $<$ExprProd$>$ \\
                 &$\rightarrow$ $<$ExprProd$>$ \\
                $<$ExprProd$>$ &$\rightarrow$
                $<$ExprProd$>$ $<$ProdOp$>$ $<$Atom$>$ \\
                 &$\rightarrow$ $<$Atom$>$ \\

                $<$SumSubOp$>$ &$\rightarrow$ + \\
                 &$\rightarrow$ - \\

                $<$ProdOp$>$ &$\rightarrow$ * \\
                 &$\rightarrow$ / \\

                $<$Atom$>$ &$\rightarrow$ [VarName] \\
                 &$\rightarrow$ [Number] \\
                 &$\rightarrow$ - $<$Atom$>$ \\
                 &$\rightarrow$ ($<$ExprArith$>$) \\

            \end{tabular}
    \end{center}


\begin{lstlisting}
\end{lstlisting}


\subsubsection{Boolean expressions}

For boolean expressions we have the following P\&A:


\begin{tabular}{|c|c|}
    \hline
    not & right \\
    \hline
    $>$, $<$, $>=$, $<=$, $=$, $<>$ / & left \\
    \hline
    and & left \\
    \hline
    or & left \\
    \hline
\end{tabular}

And the following grammar:

\begin{center}
        \begin{tabular}{l l}
            $<$Cond$>$ & $\rightarrow$ $<$Cond$>$ $<$BinOp$>$ $<$Cond$>$ \\
             & $\rightarrow$ \texttt{not} $<$SimpleCond$>$\\
             & $\rightarrow$ $<$SimpleCond$>$\\
            $<$SimpleCond$>$ & $\rightarrow$
            $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$ \\
            $<$BinOp$>$ & $\rightarrow$ \texttt{and}\\
             & $\rightarrow$ \texttt{or}\\
            $<$Comp$>$ & $\rightarrow$ $=$\\
             & $\rightarrow$ $>=$\\
             & $\rightarrow$ $>$\\
             & $\rightarrow$ $<=$\\
             & $\rightarrow$ $<$\\
             & $\rightarrow$ $<>$\\
        \end{tabular}
\end{center}

Following the same principe as for AE, we have here
\textit{disjonction of conjonctions of comparaisons}. By using the same
mechanics as above, we have this grammar:


\begin{center}
        \begin{tabular}{l l}
            $<$Cond$>$ & $\rightarrow$ $<$Cond$>$ \texttt{or} $<$ConjCond$>$ \\
             & $\rightarrow$ $<$ConjCond$>$\\

            $<$ConjCond$>$ & $\rightarrow$
            $<$ConjCond$>$ \texttt{and} $<$AtomCond$>$\\
             & $\rightarrow$ $<$AtomCond$>$\\

            $<$AtomCond$>$ & $\rightarrow$ $<$SimpleCond$>$\\
             & $\rightarrow$ \texttt{not} $<$SimpleCond$>$\\

            $<$SimpleCond$>$ & $\rightarrow$
            $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$\\

            $<$Comp$>$ & $\rightarrow$ $=$\\
             & $\rightarrow$ $>=$\\
             & $\rightarrow$ $>$\\
             & $\rightarrow$ $<=$\\
             & $\rightarrow$ $<$\\
             & $\rightarrow$ $<>$\\
        \end{tabular}
\end{center}

\subsection{Removing left recusion}

For the new AE:


\begin{center}
        \begin{tabular}{l l}
            $<$ExprArith$>$ & $\rightarrow$
            $<$ExprProd$>$ $<$ExprArithPrime$>$ \\

            $<$ExprArithPrime$>$ & $\rightarrow$
            $<$SumSubOp$>$ $<$ExprProd$>$ $<$ExprArithPrime$>$ \\
             & $\rightarrow$ $\epsilon$\\


            $<$ExprProd$>$ & $\rightarrow$ $<$Atom$>$ $<$ExprProdPrime$>$\\

            $<$ExprProdPrime$>$ & $\rightarrow$
            $<$ProdOp$>$ $<$Atom$>$ $<$ExprProdPrime$>$\\
             & $\rightarrow$ $\epsilon$\\


            $<$SumSubOp$>$ & $\rightarrow$ $+$\\
             & $\rightarrow$ $-$\\

            $<$ProdOp$>$ & $\rightarrow$ $*$\\
             & $\rightarrow$ $/$\\

            $<$Atom$>$ & $\rightarrow$ [VarName]\\
             & $\rightarrow$ [Number]\\
             & $\rightarrow$ - $<$Atom$>$\\
             & $\rightarrow$ ($<$ExprArith$>$)\\

        \end{tabular}
\end{center}

For the new BE:


\begin{center}
        \begin{tabular}{l l}
            $<$Cond$>$ & $\rightarrow$ $<$ConjCond$>$ $<$CondPrime$>$ \\


            $<$CondPrime$>$ & $\rightarrow$
            \texttt{or} $<$ConjCond$>$ $<$CondPrime$>$ \\
             & $\rightarrow$ $\epsilon$ \\

            $<$ConjCond$>$ & $\rightarrow$ $<$AtomCond$>$ $<$ConjCondPrime$>$ \\


            $<$ConjCondPrime$>$ & $\rightarrow$
            and $<$AtomCond$>$ $<$ConjCondPrime$>$ \\
             & $\rightarrow$ $\epsilon$\\

            $<$AtomCond$>$ & $\rightarrow$ $<$SimpleCond$>$\\
             & $\rightarrow$ \texttt{not} $<$SimpleCond$>$\\

            $<$SimpleCond$>$ & $\rightarrow$
            $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$\\

            $<$Comp$>$ & $\rightarrow$ =\\
             & $\rightarrow$ $>=$\\
             & $\rightarrow$ $>$\\
             & $\rightarrow$ $<=$\\
             & $\rightarrow$ $<$\\
             & $\rightarrow$ $<>$\\

        \end{tabular}
\end{center}

Those are the only rules where left-recusion appears, all the other rules
are right-recusion or no recursion at all.

\subsection{Factorisation}

We can only factorize the following set of rules: $<InstList>$, $<If>$, $<For>$.

We have the following new rules:

\begin{center}
        \begin{tabular}{l l}
            $<$InstList$>$ & $\rightarrow$ $<$Instruction$>$ $<$InstListSeq$>$\\
            $<$InstListSeq$>$ & $\rightarrow$ ; $<$InstList$>$\\
             & $\rightarrow$ $\epsilon$\\

            $<$If$>$ & $\rightarrow$
            \texttt{if} $<$Cond$>$ \texttt{then} $<$Code$>$ $<$IfSeq$>$\\
            $<$IfSeq$>$ & $\rightarrow$ \texttt{endif}\\
             & $\rightarrow$
             \texttt{else} $<$Code$>$ \texttt{endif}\\

            $<$For$>$ & $\rightarrow$
            \texttt{for} [VarName] \texttt{from}
            $<$ExprArith$>$ $<$ForOp$>$ \\
            &$\quad$\texttt{to}
            $<$ExprArith$>$ \texttt{do} $<$Code$>$ \texttt{done}\\

            $<$ForOp$>$ & $\rightarrow$ \texttt{by} $<$ExprArith$>$\\
             & $\rightarrow$ $\epsilon$\\

        \end{tabular}
\end{center}

\subsection{Transformed Grammar}

\begin{figure}
    \begin{center}
            \begin{tabular}{r l l}
                $[1]$ & $<$Program$>$ & $\rightarrow$ \texttt{begin} $<$Code$>$
                \texttt{end} \\

                $[2]$ & $<$Code$>$ & $\rightarrow$ $<$InstList$>$ \\
                $[3]$ & & $\rightarrow$ $\epsilon$ \\

                $[4]$ & $<$InstList$>$ & $\rightarrow$ $<$Instruction$>$
                $<$InstListSeq$>$ \\

                $[5]$ & $<$InstListSeq$>$ & $\rightarrow$ ; $<$InstList$>$ \\
                $[6]$ & & $\rightarrow$ $\epsilon$ \\

                $[7]$ & $<$Instruction$>$ & $\rightarrow$ $<$Assign$>$ \\
                $[8]$ &                   & $\rightarrow$ $<$If$>$ \\
                $[9]$ &                   & $\rightarrow$ $<$While$>$ \\
                $[10]$ &                   & $\rightarrow$ $<$For$>$ \\
                $[11]$ &                   & $\rightarrow$ $<$Print$>$ \\
                $[12]$ &                   & $\rightarrow$ $<$Read$>$ \\

                $[13]$ & $<$Assign$>$ & $\rightarrow$
                 [VarName] := $<$ExprArith$>$  \\

                $[14]$ & $<$ExprArith$>$ & $\rightarrow$
                $<$ExprProd$>$ $<$ExprArithPrime$>$ \\

                $[15]$ & $<$ExprArithPrime$>$ & $\rightarrow$
                $<$SumSubOp$>$ $<$ExprProd$>$ $<$ExprArithPrime$>$ \\
                $[16]$ & & $\rightarrow$ $\epsilon$ \\

                $[17]$ & $<$ExprProd$>$ & $\rightarrow$
                $<$Atom$>$ $<$ExprProdPrime$>$ \\

                $[18]$ & $<$ExprProdPrime$>$ & $\rightarrow$
                $<$ProdOp$>$ $<$Atom$>$ $<$ExprProdPrime$>$ \\
                $[19]$ & & $\rightarrow$ $\epsilon$ \\

                $[20]$ & $<$SumSubOp$>$ & $\rightarrow$ $+$ \\
                $[21]$ & & $\rightarrow$ $-$ \\
                $[22]$ & $<$ProdOp$>$ & $\rightarrow$ $*$ \\
                $[23]$ & & $\rightarrow$ $/$ \\
                $[24]$ & $<$Atom$>$ & $\rightarrow$ [VarName] \\
                $[25]$ & & $\rightarrow$ [Number] \\
                $[26]$ & & $\rightarrow$ - $<$Atom$>$ \\
                $[27]$ & & $\rightarrow$ ($<$ExprArith$>$) \\

                $[28]$ & $<$If$>$ & $\rightarrow$
                \texttt{if} $<$Cond$>$ \texttt{then} $<$Code$>$ $<$IfSeq$>$ \\
                $[29]$ & $<$IfSeq$>$ & $\rightarrow$
                \texttt{endif} \\
                $[30]$ & & $\rightarrow$
                \texttt{else} $<$Code$>$ \texttt{endif} \\

                $[31]$ & $<$Cond$>$ & $\rightarrow$
                $<$ConjCond$>$ $<$CondPrime$>$ \\
                $[32]$ & $<$CondPrime$>$ & $\rightarrow$
                \texttt{or} $<$ConjCond$>$ $<$CondPrime$>$ \\
                $[33]$ & & $\rightarrow$ $\epsilon$ \\
                $[34]$ & $<$ConjCond$>$ & $\rightarrow$
                $<$AtomCond$>$ $<$ConjCondPrime$>$ \\
                $[35]$ & $<$ConjCondPrime$>$ & $\rightarrow$
                \texttt{and} $<$AtomCond$>$ $<$ConjCondPrime$>$ \\
                $[36]$ & & $\rightarrow$ $\epsilon$ \\
                $[37]$ & $<$AtomCond$>$ & $\rightarrow$ $<$SimpleCond$>$ \\
                $[38]$ & & $\rightarrow$ \texttt{not} $<$SimpleCond$>$ \\

                $[39]$ & $<$SimpleCond$>$ & $\rightarrow$
                $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$ \\
                $[40]$ & $<$Comp$>$ & $\rightarrow$ $=$ \\
                $[41]$ & & $\rightarrow$ $>=$ \\
                $[42]$ & & $\rightarrow$ $>$ \\
                $[43]$ & & $\rightarrow$ $<=$ \\
                $[44]$ & & $\rightarrow$ $<$ \\
                $[45]$ & & $\rightarrow$ $<>$ \\

                $[46]$ & $<$While$>$ & $\rightarrow$
                \texttt{while} $<$Cond$>$ \texttt{do}
                $<$Code$>$ \texttt{done} \\
                $[47]$ & $<$For$>$ & $\rightarrow$
                \texttt{for} [VarName] \texttt{from}
                $<$ExprArith$>$ $<$ForOp$>$ \\
                & &
                $\quad$ \texttt{to} $<$ExprArith$>$
                \texttt{do} $<$Code$>$ \texttt{done} \\
                $[48]$ & $<$ForOp$>$ & $\rightarrow$
                \texttt{by} $<$ExprArith$>$ \\
                $[49]$ & & $\rightarrow$ $\epsilon$ \\
                $[50]$ & $<$Print$>$ & $\rightarrow$
                \texttt{print}([VarName]) \\
                $[51]$ & $<$Read$>$ & $\rightarrow$ \texttt{read}([VarName]) \\



            \end{tabular}

    \end{center}
    \caption{Transformed Grammar}
    \label{fig:fullcfg}
\end{figure}

\section{LL(1)}

\subsection{First and Follow}
\begin{center}
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{r | c | c}
        & First$^1$ & Follow$^1$ \\
        \hline
        Program & begin & \\
        \hline
        Code & [VarName] if while for print read $\epsilon$ &
        end else endif done \\
        \hline
        InstList & [VarName] if while for print read &
        end else endif done \\
        \hline
        InstListSeq & ; $\epsilon$ &
        end else endif done \\
        \hline
        Instruction & [VarName] if while for print read &
        ; end else endif done \\
        \hline
        Assign & [VarName] &
        ; end else endif done \\
        \hline
        ExprArith & [VarName] [Number] - ( &
        ; end else endif done ) \\
        & & $=$ $>=$ $>$ $<=$ $<$ $<>$ \\
        % & & or then do \\
        \hline
        ExprArithPrime & & \\
        \hline
        ExprProd & [VarName] [Number] - ( & \\
        \hline
        ExprProdPrime & * / $\epsilon$ & \\
        \hline
        SumSubOp & + - & \\
        \hline
        ProdOp & * / & \\
        \hline
        If & if & \\
        \hline
        Atom & [VarName] [Number] - ( & \\
        \hline
        IfSeq & endif else & \\
        \hline
        Cond & [VarName] [Number] - ( not & \\
        \hline
        CondPrime & or $\epsilon$ & \\
        \hline
        ConjCond & [VarName] [Number] - ( not & \\
        \hline
        ConjCondPrime & and $\epsilon$ & \\
        \hline
        AtomCond & [VarName] [Number] - ( not & \\
        \hline
        SimpleCond & [VarName] [Number] - ( & \\
        \hline
        Comp & $=$ $>=$ $>$ $<=$ $<$ $<>$ & \\
        \hline
        While & while & \\
        \hline
        For & for & \\
        \hline
        ForOp & by $\epsilon$ & \\
        \hline
        Print & print & \\
        \hline
        Read & read & \\
        \hline
    \end{tabular}
\end{center}

\end{document}
