\documentclass[letterpaper]{article}
\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[margin=3.5cm]{geometry}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{graphicx}%images
\usepackage{fancyhdr}%for headers and footers
\usepackage{adjustbox}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{array}
\usepackage{mathpazo}
\usepackage{subcaption}
\usepackage{float}
\usepackage{csvsimple}
\usepackage{filecontents}
\usepackage{lscape}
\usepackage{afterpage}
\usepackage{hyperref}
\usepackage{inconsolata}
\usepackage{color}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\lstset{language=Java,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\ttfamily,
  moredelim=[il][\textcolor{pgrey}]{$ $},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}



\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}


% ------ HEADERS AND FOOTERS -----------
% \lhead{INFO-F403}
% \rhead{Project Report - Part 1}
%\pagestyle{fancy}
% \rfoot{\thepage}
%\cfoot{}
%\lfoot{Academic Year 2017-18}

\begin{document}
\begin{titlepage}
\begin{center}


\textsc{\LARGE universit\'e libre de bruxelles}\\[1.0cm]
\textsc{\Large D\'epartment d'Informatique}\\[1.5cm]

% Upper part of the page. The '~' is needed because \\
% only works if a paragraph has started.
\includegraphics[width=0.2\textwidth]{image/ulblogo.jpg}~\\[1cm]

\textsc{\Large INFO-F403 - Introduction to language theory and compiling
\\[0.3cm]}
% Title
% \HRule \\[0.4cm]

{ \huge \bfseries Project Report â€“ Part 2  \\[0.4cm] }

% \HRule \\[1.5cm]

% Author and supervisor
\noindent
\begin{center} \large

\emph{Author:}\\
Hakim \textsc{Boulahya}\\
\end{center}
\begin{center} \large

\emph{Professor:} \\
Gilles \textsc{Geeraerts}\\

\end{center}

\vfill

% Bottom of the page
{\large \today}

\end{center}
\end{titlepage}

\tableofcontents
\newpage

\section{Grammar}
\paragraph{Unproductive/unreachable symbols}

In the given grammar, there is no unproductive and/or unreachable symbols.

\subsection{Priority and associativity of the operators}

\paragraph{Notation} In this section, P\&A refers to priority and associativity
of the operators, AE to arithmetic expression and BE to boolean expression.

\paragraph{}

An AE must always be \textit{processed}
before being compared
to another AE in a BE. Logically, we will consider first to unambiguous
the arithmetic expressions and then the boolean expressions.

\subsubsection{Arithmetic expressions}

\paragraph{}

Let's consider the P\&A of arithmetic expressions in Figure \ref{fig:AE-pa}
and the initial grammar in Figure \ref{fig:AE-initial}.

\begin{figure}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Operators & Associativity \\
        \hline
        \hline
        - & right \\
        \hline
        *, / & left \\
        \hline
        +, - & left \\
        \hline
    \end{tabular}
    \caption{Priority and associativity of AE}
    \label{fig:AE-pa}
\end{figure}

\begin{figure}[H]
        \centering
        \begin{tabular}{l l}
            $<$ExprArith$>$ &$\rightarrow$ [VarName] \\
             &$\rightarrow$ [Number] \\
             &$\rightarrow$ ($<$ExprArith$>$) \\
             &$\rightarrow$ - $<$ExprArith$>$ \\
             &$\rightarrow$
            $<$ExprArith$>$ $<$Op$>$ $<$ExprArith$>$ \\
            $<$Op$>$ &$\rightarrow$ $+$ \\
             &$\rightarrow$ $-$ \\
             &$\rightarrow$ $*$ \\
             &$\rightarrow$ $/$ \\
        \end{tabular}
        \caption{Initial grammar of AE}
        \label{fig:AE-initial}
\end{figure}

As mention in the course page 111, an AE must be a \textit{sum of products},
more specifically in our case a \textit{\{sum, substraction\}
of \{produts, division\}}. We will use the same atom definition
 as in the course,
with \texttt{[Number]} as the constant rule and \texttt{[VarName]}
as the id rule.
The minus operator as a right associativity means that it is always linked
to the atom next to it, so we will set this operator directly as
an atom rule.
Same thing goes for the parenthesis, it should be handled without considering
the operators outside the parenthesis, so as an atom.
Figure \ref{fig:AE-unambi} show the unambiguous grammar of AE.

\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$ExprArith$>$ &$\rightarrow$
        $<$ExprArith$>$ $<$SumSubOp$>$ $<$ExprProd$>$ \\
         &$\rightarrow$ $<$ExprProd$>$ \\
        $<$ExprProd$>$ &$\rightarrow$
        $<$ExprProd$>$ $<$ProdOp$>$ $<$Atom$>$ \\
         &$\rightarrow$ $<$Atom$>$ \\

        $<$SumSubOp$>$ &$\rightarrow$ + \\
         &$\rightarrow$ - \\

        $<$ProdOp$>$ &$\rightarrow$ * \\
         &$\rightarrow$ / \\

        $<$Atom$>$ &$\rightarrow$ [VarName] \\
         &$\rightarrow$ [Number] \\
         &$\rightarrow$ - $<$Atom$>$ \\
         &$\rightarrow$ ($<$ExprArith$>$) \\
    \end{tabular}
    \caption{Unambiguous grammar of AE}
    \label{fig:AE-unambi}
\end{figure}


\subsubsection{Boolean expressions}

Let's consider the P\&A of boolean expressions in Figure \ref{fig:BE-pa}
and the initial grammar in Figure \ref{fig:BE-initial}.

\begin{figure}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Operators & Associativity \\
        \hline
        \hline
        not & right \\
        \hline
        $>$, $<$, $>=$, $<=$, $=$, $<>$ / & left \\
        \hline
        and & left \\
        \hline
        or & left \\
        \hline
    \end{tabular}
    \caption{Priority and associativity of BE}
    \label{fig:BE-pa}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$Cond$>$ & $\rightarrow$ $<$Cond$>$ $<$BinOp$>$ $<$Cond$>$ \\
         & $\rightarrow$ \texttt{not} $<$SimpleCond$>$\\
         & $\rightarrow$ $<$SimpleCond$>$\\
        $<$SimpleCond$>$ & $\rightarrow$
        $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$ \\
        $<$BinOp$>$ & $\rightarrow$ \texttt{and}\\
         & $\rightarrow$ \texttt{or}\\
        $<$Comp$>$ & $\rightarrow$ $=$\\
         & $\rightarrow$ $>=$\\
         & $\rightarrow$ $>$\\
         & $\rightarrow$ $<=$\\
         & $\rightarrow$ $<$\\
         & $\rightarrow$ $<>$\\
    \end{tabular}
    \caption{Initial grammar of BE}
    \label{fig:BE-initial}

\end{figure}

Following the same principle as for AE, we have here
\textit{disjonction of conjonctions}. Figure \ref{fig:BE-unambi}
shows the unambiguous grammar of BE.


\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$Cond$>$ & $\rightarrow$ $<$Cond$>$ \texttt{or} $<$ConjCond$>$ \\
         & $\rightarrow$ $<$ConjCond$>$\\

        $<$ConjCond$>$ & $\rightarrow$
        $<$ConjCond$>$ \texttt{and} $<$AtomCond$>$\\
         & $\rightarrow$ $<$AtomCond$>$\\

        $<$AtomCond$>$ & $\rightarrow$ $<$SimpleCond$>$\\
         & $\rightarrow$ \texttt{not} $<$SimpleCond$>$\\

        $<$SimpleCond$>$ & $\rightarrow$
        $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$\\

        $<$Comp$>$ & $\rightarrow$ $=$\\
         & $\rightarrow$ $>=$\\
         & $\rightarrow$ $>$\\
         & $\rightarrow$ $<=$\\
         & $\rightarrow$ $<$\\
         & $\rightarrow$ $<>$\\
    \end{tabular}
    \caption{Unambiguous grammar of BE}
    \label{fig:BE-unambi}

\end{figure}


\subsection{Removing left recusion}
\paragraph{}

The only rules where left-recursion appears with \texttt{$<$ExprArith$>$},
\texttt{$<$ExprProd$>$}, \texttt{$<$Cond$>$} and \texttt{$<$ConjCond$>$}
variables
that are in the unambiguous grammar.
We have to remove the left-recursion for the unambiguous grammar
in Figure \ref{fig:AE-unambi} and \ref{fig:BE-unambi}. The transformed
grammars are shown in Figure \ref{fig:AE-noleft} and \ref{fig:BE-noleft}.
To enhance readability of new introduced rules,
we used the word \textit{Prime} instead of the character itself.

Those are the only rules where left-recusion appears (including indirect
left-recursion), all the other rules
are right-recusion or no recursion at all.
\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$ExprArith$>$ & $\rightarrow$
        $<$ExprProd$>$ $<$ExprArithPrime$>$ \\

        $<$ExprArithPrime$>$ & $\rightarrow$
        $<$SumSubOp$>$ $<$ExprProd$>$ $<$ExprArithPrime$>$ \\
         & $\rightarrow$ $\epsilon$\\


        $<$ExprProd$>$ & $\rightarrow$ $<$Atom$>$ $<$ExprProdPrime$>$\\

        $<$ExprProdPrime$>$ & $\rightarrow$
        $<$ProdOp$>$ $<$Atom$>$ $<$ExprProdPrime$>$\\
         & $\rightarrow$ $\epsilon$\\


        $<$SumSubOp$>$ & $\rightarrow$ $+$\\
         & $\rightarrow$ $-$\\

        $<$ProdOp$>$ & $\rightarrow$ $*$\\
         & $\rightarrow$ $/$\\

        $<$Atom$>$ & $\rightarrow$ [VarName]\\
         & $\rightarrow$ [Number]\\
         & $\rightarrow$ - $<$Atom$>$\\
         & $\rightarrow$ ($<$ExprArith$>$)\\

    \end{tabular}
    \caption{Left-recursion removed for AE grammar}
    \label{fig:AE-noleft}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$Cond$>$ & $\rightarrow$ $<$ConjCond$>$ $<$CondPrime$>$ \\


        $<$CondPrime$>$ & $\rightarrow$
        \texttt{or} $<$ConjCond$>$ $<$CondPrime$>$ \\
         & $\rightarrow$ $\epsilon$ \\

        $<$ConjCond$>$ & $\rightarrow$ $<$AtomCond$>$ $<$ConjCondPrime$>$ \\


        $<$ConjCondPrime$>$ & $\rightarrow$
        and $<$AtomCond$>$ $<$ConjCondPrime$>$ \\
         & $\rightarrow$ $\epsilon$\\

        $<$AtomCond$>$ & $\rightarrow$ $<$SimpleCond$>$\\
         & $\rightarrow$ \texttt{not} $<$SimpleCond$>$\\

        $<$SimpleCond$>$ & $\rightarrow$
        $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$\\

        $<$Comp$>$ & $\rightarrow$ =\\
         & $\rightarrow$ $>=$\\
         & $\rightarrow$ $>$\\
         & $\rightarrow$ $<=$\\
         & $\rightarrow$ $<$\\
         & $\rightarrow$ $<>$\\

    \end{tabular}
    \caption{Left-recursion removed for BE grammar}
    \label{fig:BE-noleft}
\end{figure}

\subsection{Factorisation}

\paragraph{}

We can only factorize the following variables:
\texttt{$<$InstList$>$}, \texttt{$<$If$>$} and \texttt{$<$For$>$}.
Figure \ref{fig:facto} shows the factorized rules.

\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$InstList$>$ & $\rightarrow$ $<$Instruction$>$ $<$InstListSeq$>$\\
        $<$InstListSeq$>$ & $\rightarrow$ ; $<$InstList$>$\\
         & $\rightarrow$ $\epsilon$\\

        $<$If$>$ & $\rightarrow$
        \texttt{if} $<$Cond$>$ \texttt{then} $<$Code$>$ $<$IfSeq$>$\\
        $<$IfSeq$>$ & $\rightarrow$ \texttt{endif}\\
         & $\rightarrow$
         \texttt{else} $<$Code$>$ \texttt{endif}\\

        $<$For$>$ & $\rightarrow$
        \texttt{for} [VarName] \texttt{from}
        $<$ExprArith$>$ $<$ForOp$>$ \\
        &$\quad$\texttt{to}
        $<$ExprArith$>$ \texttt{do} $<$Code$>$ \texttt{done}\\

        $<$ForOp$>$ & $\rightarrow$ \texttt{by} $<$ExprArith$>$\\
         & $\rightarrow$ $\epsilon$\\

    \end{tabular}
    \caption{Factorized rules}
    \label{fig:facto}
\end{figure}

\subsection{Transformed Grammar}

\paragraph{}

The complete transformed grammar is shown in Figure \ref{fig:fullcfg}.

\afterpage{
\newgeometry{margin=2.5cm}
\begin{figure}[H]
    \centering
    \begin{tabular}{r l l}
        $[1]$ & $<$Program$>$ & $\rightarrow$ \texttt{begin} $<$Code$>$
        \texttt{end} \\

        $[2]$ & $<$Code$>$ & $\rightarrow$ $<$InstList$>$ \\
        $[3]$ & & $\rightarrow$ $\epsilon$ \\

        $[4]$ & $<$InstList$>$ & $\rightarrow$ $<$Instruction$>$
        $<$InstListSeq$>$ \\

        $[5]$ & $<$InstListSeq$>$ & $\rightarrow$ ; $<$InstList$>$ \\
        $[6]$ & & $\rightarrow$ $\epsilon$ \\

        $[7]$ & $<$Instruction$>$ & $\rightarrow$ $<$Assign$>$ \\
        $[8]$ &                   & $\rightarrow$ $<$If$>$ \\
        $[9]$ &                   & $\rightarrow$ $<$While$>$ \\
        $[10]$ &                   & $\rightarrow$ $<$For$>$ \\
        $[11]$ &                   & $\rightarrow$ $<$Print$>$ \\
        $[12]$ &                   & $\rightarrow$ $<$Read$>$ \\

        $[13]$ & $<$Assign$>$ & $\rightarrow$
         [VarName] := $<$ExprArith$>$  \\

        $[14]$ & $<$ExprArith$>$ & $\rightarrow$
        $<$ExprProd$>$ $<$ExprArithPrime$>$ \\

        $[15]$ & $<$ExprArithPrime$>$ & $\rightarrow$
        $<$SumSubOp$>$ $<$ExprProd$>$ $<$ExprArithPrime$>$ \\
        $[16]$ & & $\rightarrow$ $\epsilon$ \\

        $[17]$ & $<$ExprProd$>$ & $\rightarrow$
        $<$Atom$>$ $<$ExprProdPrime$>$ \\

        $[18]$ & $<$ExprProdPrime$>$ & $\rightarrow$
        $<$ProdOp$>$ $<$Atom$>$ $<$ExprProdPrime$>$ \\
        $[19]$ & & $\rightarrow$ $\epsilon$ \\

        $[20]$ & $<$SumSubOp$>$ & $\rightarrow$ $+$ \\
        $[21]$ & & $\rightarrow$ $-$ \\
        $[22]$ & $<$ProdOp$>$ & $\rightarrow$ $*$ \\
        $[23]$ & & $\rightarrow$ $/$ \\
        $[24]$ & $<$Atom$>$ & $\rightarrow$ [VarName] \\
        $[25]$ & & $\rightarrow$ [Number] \\
        $[26]$ & & $\rightarrow$ - $<$Atom$>$ \\
        $[27]$ & & $\rightarrow$ ($<$ExprArith$>$) \\

        $[28]$ & $<$If$>$ & $\rightarrow$
        \texttt{if} $<$Cond$>$ \texttt{then} $<$Code$>$ $<$IfSeq$>$ \\
        $[29]$ & $<$IfSeq$>$ & $\rightarrow$
        \texttt{endif} \\
        $[30]$ & & $\rightarrow$
        \texttt{else} $<$Code$>$ \texttt{endif} \\

        $[31]$ & $<$Cond$>$ & $\rightarrow$
        $<$ConjCond$>$ $<$CondPrime$>$ \\
        $[32]$ & $<$CondPrime$>$ & $\rightarrow$
        \texttt{or} $<$ConjCond$>$ $<$CondPrime$>$ \\
        $[33]$ & & $\rightarrow$ $\epsilon$ \\
        $[34]$ & $<$ConjCond$>$ & $\rightarrow$
        $<$AtomCond$>$ $<$ConjCondPrime$>$ \\
        $[35]$ & $<$ConjCondPrime$>$ & $\rightarrow$
        \texttt{and} $<$AtomCond$>$ $<$ConjCondPrime$>$ \\
        $[36]$ & & $\rightarrow$ $\epsilon$ \\
        $[37]$ & $<$AtomCond$>$ & $\rightarrow$ $<$SimpleCond$>$ \\
        $[38]$ & & $\rightarrow$ \texttt{not} $<$SimpleCond$>$ \\

        $[39]$ & $<$SimpleCond$>$ & $\rightarrow$
        $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$ \\
        $[40]$ & $<$Comp$>$ & $\rightarrow$ $=$ \\
        $[41]$ & & $\rightarrow$ $>=$ \\
        $[42]$ & & $\rightarrow$ $>$ \\
        $[43]$ & & $\rightarrow$ $<=$ \\
        $[44]$ & & $\rightarrow$ $<$ \\
        $[45]$ & & $\rightarrow$ $<>$ \\

        $[46]$ & $<$While$>$ & $\rightarrow$
        \texttt{while} $<$Cond$>$ \texttt{do}
        $<$Code$>$ \texttt{done} \\
        $[47]$ & $<$For$>$ & $\rightarrow$
        \texttt{for} [VarName] \texttt{from}
        $<$ExprArith$>$ $<$ForOp$>$ \\
        & &
        $\quad$ \texttt{to} $<$ExprArith$>$
        \texttt{do} $<$Code$>$ \texttt{done} \\
        $[48]$ & $<$ForOp$>$ & $\rightarrow$
        \texttt{by} $<$ExprArith$>$ \\
        $[49]$ & & $\rightarrow$ $\epsilon$ \\
        $[50]$ & $<$Print$>$ & $\rightarrow$
        \texttt{print}([VarName]) \\
        $[51]$ & $<$Read$>$ & $\rightarrow$ \texttt{read}([VarName]) \\
    \end{tabular}
    \caption{Transformed Grammar}
    \label{fig:fullcfg}
\end{figure}
\clearpage
\restoregeometry
}

\section{LL(1) parser}

\subsection{First$^1(\cdot)$ and Follow$^1(\cdot)$}
\afterpage{
\newgeometry{margin=3cm}
\begin{figure}[H]
    \centering
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{| r || c | c |}
        \hline
        \textbf{Variables} & \textbf{First$^1(\cdot)$}
        & \textbf{Follow$^1(\cdot)$} \\
        \hline
        \hline
        Program & begin & \\
        \hline
        Code & [VarName] if while for print read $\epsilon$ &
        end else endif done \\
        \hline
        InstList & [VarName] if while for print read &
        end else endif done \\
        \hline
        InstListSeq & ; $\epsilon$ &
        end else endif done \\
        \hline
        Instruction & [VarName] if while for print read &
        ; end else endif done \\
        \hline
        Assign & [VarName] &
        ; end else endif done \\
        \hline
        ExprArith & [VarName] [Number] - ( &
        ; end else endif done ) \\
        & & $=$ $>=$ $>$ $<=$ $<$ $<>$ \\
        & & and or then do \\
        & &  by to\\
        % & & or then do \\
        \hline
        ExprArithPrime & + - $\epsilon$ &
        Follow$^1$($<$ExprArith$>$) \\
        \hline
        ExprProd & [VarName] [Number] - ( &
        + - Follow$^1$($<$ExprArith$>$) \\
        \hline
        ExprProdPrime & * / $\epsilon$ &
        + - Follow$^1$($<$ExprArith$>$) \\
        \hline
        SumSubOp & + - & [VarName] [Number] - ( \\
        \hline
        ProdOp & * / & [VarName] [Number] - ( \\
        \hline
        If & if & ; end else endif done \\
        \hline
        Atom & [VarName] [Number] - ( &
        * / + - Follow$^1$($<$ExprArith$>$) \\
        \hline
        IfSeq & endif else & ; end else endif done \\
        \hline
        Cond & [VarName] [Number] - ( not & then do \\
        \hline
        CondPrime & or $\epsilon$ & then do \\
        \hline
        ConjCond & [VarName] [Number] - ( not &
        or then do  \\
        \hline
        ConjCondPrime & and $\epsilon$ & or then do\\
        \hline
        AtomCond & [VarName] [Number] - ( not &
        and or then do \\
        \hline
        SimpleCond & [VarName] [Number] - ( &
        and or then do \\
        \hline
        Comp & $=$ $>=$ $>$ $<=$ $<$ $<>$ &
        [VarName] [Number] - ( \\
        \hline
        While & while & ; end else endif done \\
        \hline
        For & for & ; end else endif done \\
        \hline
        ForOp & by $\epsilon$ & to \\
        \hline
        Print & print & ; end else endif done \\
        \hline
        Read & read & ; end else endif done \\
        \hline
    \end{tabular}
    \caption{First$^1$ and Follow$^1$ results}
    \label{fig:firstfollow}
\end{figure}
\clearpage
\restoregeometry
}

\paragraph{}

To be able to generate the action table of our LL(1) parser, it is necessary
to show the results of the First$^1(\cdot)$ and Follow$^1(\cdot)$
computation of each variables
belonging to the grammar. The results are shown in Figure \ref{fig:firstfollow}.

\subsection{Action table}

\paragraph{}

The action table is available as a comma separated \texttt{.csv} file in
\textbf{doc/actionTable.csv}. This file only contains the
\textit{produce} rules.
It is not necessary to include the table that matches terminals together
since the only results possible is the action \textit{match}
for terminals that are the same.
In the case of the \texttt{end} terminal, the action is \textit{accept}.
An empty cell in the table induce a syntax error.
Section \ref{implactiontable} discuss in more details the implementation
of the action table.

Let $G<V, T, P, S>$ our transformed grammar.
Let the action table be $M(v, t)$ where
$v \in V$, and $t \in T$.

$M$ is filled in as follow:
\begin{itemize}
    \item $\forall v \in V$ and $\forall t \in$ First$^1(v)$,
    then set $M(v, t)$ as the rule number where $t$ is first.
    \item $\forall v \in V$ if $\epsilon \in $ First$^1(v)$ then
    $\forall t \in$ Follow$^1(v)$ set $M(v, t)$ as the rule number
    where $v \rightarrow \epsilon$.
\end{itemize}

We will explain in more details the results of other possible results
of the action table $M$ in section \ref{implactiontable}.

\section{Implementation}

\subsubsection{Scanner improvements}

\paragraph{Read input}
In the first part of the project we were asked to implement a scanner.
To be able to use the scanner within the parser, we modified some part of the
scanner. The scanner is implemented in the abstract class \texttt{Scanner}.
The lexer generated class is named \texttt{GeneratedScanner} and will
implement the \texttt{Scanner}. To be able to read the input, \textit{i.e.}
the tokens, the method \texttt{Scanner.scan()} must be called, and
will return a list of \texttt{Symbol}. It is still possible to run the scanner
as a standalone application, see section \ref{howto}.
Figure \ref{fig:scannercall} shows an example of use of the scanner.

\begin{figure}[H]
    \begin{lstlisting}
    Scanner scanner = new GeneratedScanner(source);
    List<Symbol> symbols = scanner.scan();
    \end{lstlisting}
    \caption{Call the scanner to read the tokens from a source file}
    \label{fig:scannercall}
\end{figure}

\paragraph{Lexer improvements}

Two improvements were made in the lexer. (1) We modified the any ASCII
characters
regex \texttt{.} (dot) to regex that matches the complement of the
empty set \texttt{[\textasciicircum]}.
(2) Instead of printing \texttt{"Unkown symbol"}
and continue the scan when
a unrecognize symbol is detected, the scanner throw a
\texttt{UnknownTokenException} which logically stops the scan.



\subsection{Parser}

\subsubsection{Action table $M$}

\label{implactiontable}

\section{HowTo}

\label{howto}

\end{document}
