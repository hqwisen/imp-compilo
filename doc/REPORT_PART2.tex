\documentclass[letterpaper]{article}
\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{graphicx}%images
\usepackage{fancyhdr}%for headers and footers

\usepackage{xcolor}
\usepackage{adjustbox}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{fancyhdr}

\usepackage{multirow}
\usepackage{amsmath}
\usepackage{array}
\usepackage{mathpazo}
\usepackage{subcaption}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}


% ------ HEADERS AND FOOTERS -----------
% \lhead{INFO-F403}
% \rhead{Project Report - Part 1}
\pagestyle{fancy}
% \rfoot{\thepage}
%\cfoot{}
%\lfoot{Academic Year 2017-18}

\begin{document}
\begin{titlepage}
\begin{center}


\textsc{\LARGE universit\'e libre de bruxelles}\\[1.0cm]
\textsc{\Large D\'epartment d'Informatique}\\[1.5cm]

% Upper part of the page. The '~' is needed because \\
% only works if a paragraph has started.
\includegraphics[width=0.2\textwidth]{image/ulblogo.jpg}~\\[1cm]

\textsc{\Large INFO-F403 - Introduction to language theory and compiling
\\[0.3cm]}
% Title
% \HRule \\[0.4cm]

{ \huge \bfseries Project Report â€“ Part 2  \\[0.4cm] }

% \HRule \\[1.5cm]

% Author and supervisor
\noindent
\begin{center} \large

\emph{Author:}\\
Hakim \textsc{Boulahya}\\
\end{center}
\begin{center} \large

\emph{Professor:} \\
Gilles \textsc{Geeraerts}\\

\end{center}

\vfill

% Bottom of the page
{\large \today}

\end{center}
\end{titlepage}

\tableofcontents
\newpage

\section{Grammar}
\paragraph{Unproductive/unreachable symbols}

In the given grammar, there is no unproductive and/or unreachable symbols.

\subsection{Priority and associativity of the operators}

\paragraph{Notation} In this section, P\&A refers to priority and associativity
of the operators, AE to arithmetic expression and BE to boolean expression.

\paragraph{}

An AE must always be \textit{processed}
before being compared
to another AE in a BE. Logically, we will consider first to unambiguous
the arithmetic expressions and then the boolean expressions.

\subsubsection{Arithmetic expressions}

\paragraph{}

Let's consider the P\&A of arithmetic expressions in Figure \ref{fig:AE-pa}
and the initial grammar in Figure \ref{fig:AE-initial}.

\begin{figure}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Operators & Associativity \\
        \hline
        \hline
        - & right \\
        \hline
        *, / & left \\
        \hline
        +, - & left \\
        \hline
    \end{tabular}
    \caption{Priority and associativity of AE}
    \label{fig:AE-pa}
\end{figure}

\begin{figure}[H]
        \centering
        \begin{tabular}{l l}
            $<$ExprArith$>$ &$\rightarrow$ [VarName] \\
             &$\rightarrow$ [Number] \\
             &$\rightarrow$ ($<$ExprArith$>$) \\
             &$\rightarrow$ - $<$ExprArith$>$ \\
             &$\rightarrow$
            $<$ExprArith$>$ $<$Op$>$ $<$ExprArith$>$ \\
            $<$Op$>$ &$\rightarrow$ $+$ \\
             &$\rightarrow$ $-$ \\
             &$\rightarrow$ $*$ \\
             &$\rightarrow$ $/$ \\
        \end{tabular}
        \caption{Initial grammar of AE}
        \label{fig:AE-initial}
\end{figure}

As mention in the course page 111, an AE must be a \textit{sum of products},
more specifically in our case a \textit{\{sum, substraction\}
of \{produts, division\}}. We will use the same atom definition
 as in the course,
with \texttt{[Number]} as the constant rule and \texttt{[VarName]}
as the id rule.
The minus operator as a right associativity means that it is always linked
to the atom next to it, so we will set this operator directly as
an atom rule.
Same thing goes for the parenthesis, it should be handled without considering
the operators outside the parenthesis, so as an atom.
Figure \ref{fig:AE-unambi} show the unambiguous grammar of AE.

\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$ExprArith$>$ &$\rightarrow$
        $<$ExprArith$>$ $<$SumSubOp$>$ $<$ExprProd$>$ \\
         &$\rightarrow$ $<$ExprProd$>$ \\
        $<$ExprProd$>$ &$\rightarrow$
        $<$ExprProd$>$ $<$ProdOp$>$ $<$Atom$>$ \\
         &$\rightarrow$ $<$Atom$>$ \\

        $<$SumSubOp$>$ &$\rightarrow$ + \\
         &$\rightarrow$ - \\

        $<$ProdOp$>$ &$\rightarrow$ * \\
         &$\rightarrow$ / \\

        $<$Atom$>$ &$\rightarrow$ [VarName] \\
         &$\rightarrow$ [Number] \\
         &$\rightarrow$ - $<$Atom$>$ \\
         &$\rightarrow$ ($<$ExprArith$>$) \\
    \end{tabular}
    \caption{Unambiguous grammar of AE}
    \label{fig:AE-unambi}
\end{figure}


\subsubsection{Boolean expressions}

Let's consider the P\&A of boolean expressions in Figure \ref{fig:BE-pa}
and the initial grammar in Figure \ref{fig:BE-initial}.

\begin{figure}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Operators & Associativity \\
        \hline
        \hline
        not & right \\
        \hline
        $>$, $<$, $>=$, $<=$, $=$, $<>$ / & left \\
        \hline
        and & left \\
        \hline
        or & left \\
        \hline
    \end{tabular}
    \caption{Priority and associativity of BE}
    \label{fig:BE-pa}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$Cond$>$ & $\rightarrow$ $<$Cond$>$ $<$BinOp$>$ $<$Cond$>$ \\
         & $\rightarrow$ \texttt{not} $<$SimpleCond$>$\\
         & $\rightarrow$ $<$SimpleCond$>$\\
        $<$SimpleCond$>$ & $\rightarrow$
        $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$ \\
        $<$BinOp$>$ & $\rightarrow$ \texttt{and}\\
         & $\rightarrow$ \texttt{or}\\
        $<$Comp$>$ & $\rightarrow$ $=$\\
         & $\rightarrow$ $>=$\\
         & $\rightarrow$ $>$\\
         & $\rightarrow$ $<=$\\
         & $\rightarrow$ $<$\\
         & $\rightarrow$ $<>$\\
    \end{tabular}
    \caption{Initial grammar of BE}
    \label{fig:BE-initial}

\end{figure}

Following the same principle as for AE, we have here
\textit{disjonction of conjonctions}. Figure \ref{fig:BE-unambi}
shows the unambiguous grammar of BE.


\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$Cond$>$ & $\rightarrow$ $<$Cond$>$ \texttt{or} $<$ConjCond$>$ \\
         & $\rightarrow$ $<$ConjCond$>$\\

        $<$ConjCond$>$ & $\rightarrow$
        $<$ConjCond$>$ \texttt{and} $<$AtomCond$>$\\
         & $\rightarrow$ $<$AtomCond$>$\\

        $<$AtomCond$>$ & $\rightarrow$ $<$SimpleCond$>$\\
         & $\rightarrow$ \texttt{not} $<$SimpleCond$>$\\

        $<$SimpleCond$>$ & $\rightarrow$
        $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$\\

        $<$Comp$>$ & $\rightarrow$ $=$\\
         & $\rightarrow$ $>=$\\
         & $\rightarrow$ $>$\\
         & $\rightarrow$ $<=$\\
         & $\rightarrow$ $<$\\
         & $\rightarrow$ $<>$\\
    \end{tabular}
    \caption{Unambiguous grammar of BE}
    \label{fig:BE-unambi}

\end{figure}


\subsection{Removing left recusion}

The only rules where left-recursion appears with \texttt{$<$ExprArith$>$}
and \texttt{$<$Cond$>$}.
variables. We have to remove the left-recursion for the unambiguous grammar
in Figure \ref{fig:AE-unambi} and \ref{fig:BE-unambi}. The transformed
grammars are shown in Figure \ref{fig:AE-noleft} and \ref{fig:BE-noleft}.
To enhance readability of new introduced rules,
we used the word \textit{Prime} instead of the character itself.

Those are the only rules where left-recusion appears (including indirect
left-recursion), all the other rules
are right-recusion or no recursion at all.
\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$ExprArith$>$ & $\rightarrow$
        $<$ExprProd$>$ $<$ExprArithPrime$>$ \\

        $<$ExprArithPrime$>$ & $\rightarrow$
        $<$SumSubOp$>$ $<$ExprProd$>$ $<$ExprArithPrime$>$ \\
         & $\rightarrow$ $\epsilon$\\


        $<$ExprProd$>$ & $\rightarrow$ $<$Atom$>$ $<$ExprProdPrime$>$\\

        $<$ExprProdPrime$>$ & $\rightarrow$
        $<$ProdOp$>$ $<$Atom$>$ $<$ExprProdPrime$>$\\
         & $\rightarrow$ $\epsilon$\\


        $<$SumSubOp$>$ & $\rightarrow$ $+$\\
         & $\rightarrow$ $-$\\

        $<$ProdOp$>$ & $\rightarrow$ $*$\\
         & $\rightarrow$ $/$\\

        $<$Atom$>$ & $\rightarrow$ [VarName]\\
         & $\rightarrow$ [Number]\\
         & $\rightarrow$ - $<$Atom$>$\\
         & $\rightarrow$ ($<$ExprArith$>$)\\

    \end{tabular}
    \caption{Left-recursion removed for AE grammar}
    \label{fig:AE-noleft}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$Cond$>$ & $\rightarrow$ $<$ConjCond$>$ $<$CondPrime$>$ \\


        $<$CondPrime$>$ & $\rightarrow$
        \texttt{or} $<$ConjCond$>$ $<$CondPrime$>$ \\
         & $\rightarrow$ $\epsilon$ \\

        $<$ConjCond$>$ & $\rightarrow$ $<$AtomCond$>$ $<$ConjCondPrime$>$ \\


        $<$ConjCondPrime$>$ & $\rightarrow$
        and $<$AtomCond$>$ $<$ConjCondPrime$>$ \\
         & $\rightarrow$ $\epsilon$\\

        $<$AtomCond$>$ & $\rightarrow$ $<$SimpleCond$>$\\
         & $\rightarrow$ \texttt{not} $<$SimpleCond$>$\\

        $<$SimpleCond$>$ & $\rightarrow$
        $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$\\

        $<$Comp$>$ & $\rightarrow$ =\\
         & $\rightarrow$ $>=$\\
         & $\rightarrow$ $>$\\
         & $\rightarrow$ $<=$\\
         & $\rightarrow$ $<$\\
         & $\rightarrow$ $<>$\\

    \end{tabular}
    \caption{Left-recursion removed for BE grammar}
    \label{fig:BE-noleft}
\end{figure}

\subsection{Factorisation}

\paragraph{}

We can only factorize the following variables:
\texttt{$<$InstList$>$}, \texttt{$<$If$>$} and \texttt{$<$For$>$}.
Figure \ref{fig:facto} shows the factorized rules.

\begin{figure}[H]
    \centering
    \begin{tabular}{l l}
        $<$InstList$>$ & $\rightarrow$ $<$Instruction$>$ $<$InstListSeq$>$\\
        $<$InstListSeq$>$ & $\rightarrow$ ; $<$InstList$>$\\
         & $\rightarrow$ $\epsilon$\\

        $<$If$>$ & $\rightarrow$
        \texttt{if} $<$Cond$>$ \texttt{then} $<$Code$>$ $<$IfSeq$>$\\
        $<$IfSeq$>$ & $\rightarrow$ \texttt{endif}\\
         & $\rightarrow$
         \texttt{else} $<$Code$>$ \texttt{endif}\\

        $<$For$>$ & $\rightarrow$
        \texttt{for} [VarName] \texttt{from}
        $<$ExprArith$>$ $<$ForOp$>$ \\
        &$\quad$\texttt{to}
        $<$ExprArith$>$ \texttt{do} $<$Code$>$ \texttt{done}\\

        $<$ForOp$>$ & $\rightarrow$ \texttt{by} $<$ExprArith$>$\\
         & $\rightarrow$ $\epsilon$\\

    \end{tabular}
    \caption{Factorized rules}
    \label{fig:facto}
\end{figure}

\subsection{Transformed Grammar}

\begin{figure}[H]
    \centering
    \begin{tabular}{r l l}
        $[1]$ & $<$Program$>$ & $\rightarrow$ \texttt{begin} $<$Code$>$
        \texttt{end} \\

        $[2]$ & $<$Code$>$ & $\rightarrow$ $<$InstList$>$ \\
        $[3]$ & & $\rightarrow$ $\epsilon$ \\

        $[4]$ & $<$InstList$>$ & $\rightarrow$ $<$Instruction$>$
        $<$InstListSeq$>$ \\

        $[5]$ & $<$InstListSeq$>$ & $\rightarrow$ ; $<$InstList$>$ \\
        $[6]$ & & $\rightarrow$ $\epsilon$ \\

        $[7]$ & $<$Instruction$>$ & $\rightarrow$ $<$Assign$>$ \\
        $[8]$ &                   & $\rightarrow$ $<$If$>$ \\
        $[9]$ &                   & $\rightarrow$ $<$While$>$ \\
        $[10]$ &                   & $\rightarrow$ $<$For$>$ \\
        $[11]$ &                   & $\rightarrow$ $<$Print$>$ \\
        $[12]$ &                   & $\rightarrow$ $<$Read$>$ \\

        $[13]$ & $<$Assign$>$ & $\rightarrow$
         [VarName] := $<$ExprArith$>$  \\

        $[14]$ & $<$ExprArith$>$ & $\rightarrow$
        $<$ExprProd$>$ $<$ExprArithPrime$>$ \\

        $[15]$ & $<$ExprArithPrime$>$ & $\rightarrow$
        $<$SumSubOp$>$ $<$ExprProd$>$ $<$ExprArithPrime$>$ \\
        $[16]$ & & $\rightarrow$ $\epsilon$ \\

        $[17]$ & $<$ExprProd$>$ & $\rightarrow$
        $<$Atom$>$ $<$ExprProdPrime$>$ \\

        $[18]$ & $<$ExprProdPrime$>$ & $\rightarrow$
        $<$ProdOp$>$ $<$Atom$>$ $<$ExprProdPrime$>$ \\
        $[19]$ & & $\rightarrow$ $\epsilon$ \\

        $[20]$ & $<$SumSubOp$>$ & $\rightarrow$ $+$ \\
        $[21]$ & & $\rightarrow$ $-$ \\
        $[22]$ & $<$ProdOp$>$ & $\rightarrow$ $*$ \\
        $[23]$ & & $\rightarrow$ $/$ \\
        $[24]$ & $<$Atom$>$ & $\rightarrow$ [VarName] \\
        $[25]$ & & $\rightarrow$ [Number] \\
        $[26]$ & & $\rightarrow$ - $<$Atom$>$ \\
        $[27]$ & & $\rightarrow$ ($<$ExprArith$>$) \\

        $[28]$ & $<$If$>$ & $\rightarrow$
        \texttt{if} $<$Cond$>$ \texttt{then} $<$Code$>$ $<$IfSeq$>$ \\
        $[29]$ & $<$IfSeq$>$ & $\rightarrow$
        \texttt{endif} \\
        $[30]$ & & $\rightarrow$
        \texttt{else} $<$Code$>$ \texttt{endif} \\

        $[31]$ & $<$Cond$>$ & $\rightarrow$
        $<$ConjCond$>$ $<$CondPrime$>$ \\
        $[32]$ & $<$CondPrime$>$ & $\rightarrow$
        \texttt{or} $<$ConjCond$>$ $<$CondPrime$>$ \\
        $[33]$ & & $\rightarrow$ $\epsilon$ \\
        $[34]$ & $<$ConjCond$>$ & $\rightarrow$
        $<$AtomCond$>$ $<$ConjCondPrime$>$ \\
        $[35]$ & $<$ConjCondPrime$>$ & $\rightarrow$
        \texttt{and} $<$AtomCond$>$ $<$ConjCondPrime$>$ \\
        $[36]$ & & $\rightarrow$ $\epsilon$ \\
        $[37]$ & $<$AtomCond$>$ & $\rightarrow$ $<$SimpleCond$>$ \\
        $[38]$ & & $\rightarrow$ \texttt{not} $<$SimpleCond$>$ \\

        $[39]$ & $<$SimpleCond$>$ & $\rightarrow$
        $<$ExprArith$>$ $<$Comp$>$ $<$ExprArith$>$ \\
        $[40]$ & $<$Comp$>$ & $\rightarrow$ $=$ \\
        $[41]$ & & $\rightarrow$ $>=$ \\
        $[42]$ & & $\rightarrow$ $>$ \\
        $[43]$ & & $\rightarrow$ $<=$ \\
        $[44]$ & & $\rightarrow$ $<$ \\
        $[45]$ & & $\rightarrow$ $<>$ \\

        $[46]$ & $<$While$>$ & $\rightarrow$
        \texttt{while} $<$Cond$>$ \texttt{do}
        $<$Code$>$ \texttt{done} \\
        $[47]$ & $<$For$>$ & $\rightarrow$
        \texttt{for} [VarName] \texttt{from}
        $<$ExprArith$>$ $<$ForOp$>$ \\
        & &
        $\quad$ \texttt{to} $<$ExprArith$>$
        \texttt{do} $<$Code$>$ \texttt{done} \\
        $[48]$ & $<$ForOp$>$ & $\rightarrow$
        \texttt{by} $<$ExprArith$>$ \\
        $[49]$ & & $\rightarrow$ $\epsilon$ \\
        $[50]$ & $<$Print$>$ & $\rightarrow$
        \texttt{print}([VarName]) \\
        $[51]$ & $<$Read$>$ & $\rightarrow$ \texttt{read}([VarName]) \\
    \end{tabular}
    \caption{Transformed Grammar}
    \label{fig:fullcfg}
\end{figure}

\section{LL(1) parser}

\subsection{First$^1(\cdot)$ and Follow$^1(\cdot)$}
To be able to generate the action table of our LL(1) parser, it is necessary
to show the results of the First$^1(\cdot)$ and Follow$^1(\cdot)$
computation of each variables
belonging to the grammar.

\begin{center}
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{| r || c | c |}
        \hline
        \textbf{Variables} & \textbf{First$^1(\cdot)$}
        & \textbf{Follow$^1(\cdot)$} \\
        \hline
        \hline
        Program & begin & \\
        \hline
        Code & [VarName] if while for print read $\epsilon$ &
        end else endif done \\
        \hline
        InstList & [VarName] if while for print read &
        end else endif done \\
        \hline
        InstListSeq & ; $\epsilon$ &
        end else endif done \\
        \hline
        Instruction & [VarName] if while for print read &
        ; end else endif done \\
        \hline
        Assign & [VarName] &
        ; end else endif done \\
        \hline
        ExprArith & [VarName] [Number] - ( &
        ; end else endif done ) \\
        & & $=$ $>=$ $>$ $<=$ $<$ $<>$ \\
        & & and or then do \\
        & &  by to\\
        % & & or then do \\
        \hline
        ExprArithPrime & + - $\epsilon$ &
        Follow$^1$($<$ExprArith$>$) \\
        \hline
        ExprProd & [VarName] [Number] - ( &
        + - Follow$^1$($<$ExprArith$>$) \\
        \hline
        ExprProdPrime & * / $\epsilon$ &
        + - Follow$^1$($<$ExprArith$>$) \\
        \hline
        SumSubOp & + - & [VarName] [Number] - ( \\
        \hline
        ProdOp & * / & [VarName] [Number] - ( \\
        \hline
        If & if & ; end else endif done \\
        \hline
        Atom & [VarName] [Number] - ( &
        * / + - Follow$^1$($<$ExprArith$>$) \\
        \hline
        IfSeq & endif else & ; end else endif done \\
        \hline
        Cond & [VarName] [Number] - ( not & then do \\
        \hline
        CondPrime & or $\epsilon$ & then do \\
        \hline
        ConjCond & [VarName] [Number] - ( not &
        or then do  \\
        \hline
        ConjCondPrime & and $\epsilon$ & or then do\\
        \hline
        AtomCond & [VarName] [Number] - ( not &
        and or then do \\
        \hline
        SimpleCond & [VarName] [Number] - ( &
        and or then do \\
        \hline
        Comp & $=$ $>=$ $>$ $<=$ $<$ $<>$ &
        [VarName] [Number] - ( \\
        \hline
        While & while & ; end else endif done \\
        \hline
        For & for & ; end else endif done \\
        \hline
        ForOp & by $\epsilon$ & to \\
        \hline
        Print & print & ; end else endif done \\
        \hline
        Read & read & ; end else endif done \\
        \hline
    \end{tabular}
\end{center}

\subsection{Action table}

\end{document}
