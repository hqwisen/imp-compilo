\documentclass[letterpaper]{article}
\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[margin=1.5in]{geometry}



\title{Introduction to language theory and compiling
\\ Project - Part 1}
\author{Universit√© Libre de Bruxelles \\
\\ Hakim Boulahya}


\begin{document}
\maketitle

\section{Definition}

\subsection{Emphasizing}

\begin{itemize}
    \item MUST
    \item OR
    \item CAN
\end{itemize}

\subsection{Notation and defintions}

\begin{itemize}
    \item case-senstive characters
    \item alpha numeric
    \item ERE: Extended Regular Expression
\end{itemize}

\section{Extended Regular Expressions}
This section describe extended regular expressions use by the lexer.
The shortcuts section describes simple ERE that are used to write
the advanced ERE.
\subsection{Shortcuts}

\begin{enumerate}
    \item \texttt{AlphaUpperCase = [A-Z]} : Match all uppercase letters
    \item \texttt{AlphaLowerCase = [a-z]} : Match all lowercase letters
    \item \texttt{Alpha = \{AlphaUpperCase\}|\{AlphaLowerCase\}} :
    Match alphabet case-sensitive characters
    \item \texttt{Numeric = [0-9]} : Match digit characters
    \item \texttt{AlphaNumeric = \{Alpha\}|\{Numeric\}} :
    Match alphabetic \textbf{OR} digit characters
\end{enumerate}

\subsection{Advanced}
\label{advanced-ere}
\begin{enumerate}
    \item \texttt{Number = ([1-9]{Numeric}*)|0} :
    Match all numbers that \textbf{MUST} start with a non-zero digit and follow
    by 0 or more digits (first RE),
    \textbf{OR} match only zero digit (second RE). This RE correspond to
    the [Number] lexical unit.
    \item \texttt{VarName = {Alpha}{AlphaNumeric}*}
    Match identifiers. Identifiers \textbf{MUST} starts with a alphabetic
    character and \textbf{CAN} be followed by 0 or more digits \textbf{OR}
    alphabetic characters.
    Correspond to the [VarName] lexical unit.
    \item \texttt{Spaces = \\s+}
\end{enumerate}

\subsection{Keyword}

\label{ere-keywords}

All the following keyword are matching \textit{themself} directly: <Include
keyword>

\section{Implementation}

\subsection{Code structure}

\paragraph{Files}

Our implementation is contained in two files: \texttt{LexicalAnalyzer.flex},
contains the ERE that analyse the input sources and \texttt{ImpCompilo.java}
that contains the Java source code, used in the regular Expressions
matching actions.


\paragraph{Code flexibility}

To allow a better code flexibility, the Jflex generated class will
\texttt{extends} \texttt{ImpCompilo} class. This allow to develop the
compilator directly from a Java source class, instead of putting the
ERE and the logical code inside the .flex file.

\subsection{Implemenation choices}

\subsubsection{States}

\paragraph{}

This section describe the states\cite{jflexdocstates} implemented in our
lexical analyzer and the corresponding ERE used.

\paragraph{}

One state is enough (necessary) to return the IMP language tokens.
The state \textbf{YYINITIAL} (the default inclusive state) is used to match
all the keywords listed in section \ref{ere-keywords}. For each keyword
the action is running the method \texttt{ImpCompilo.symbol(LexicalUnit)}.
This method runs the following instruction:
\begin{enumerate}
    \item if LexicalUnit is VarName: add it to \texttt{identifiers} dictionnary
    \item Add the symbol to \texttt{symbols}
    \item Output the symbol using the provided \texttt{toString} method.
\end{enumerate}
\paragraph{Example}

For the keyword \texttt{if}, the corresping ERE line in YYINITIAL is:
"if"             {return symbol(LexicalUnit.IF);}

\paragraph{}
[VarName] and [Number] lexical units are also handled in \textbf{YYINITIAL}.
The only difference is that the right-side of the line code is not a keyword
but the correspding ERE defined in section \ref{advanced-ere}.



\section{All in yyinitial vs states for different grammars}

\end{document}
