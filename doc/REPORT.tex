\documentclass[letterpaper]{article}
\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[margin=1.5in]{geometry}
\usepackage{listings}

\title{Introduction to language theory and compiling
\\ Project - Part 1}
\author{UniversitÃ© Libre de Bruxelles \\
\\ Hakim Boulahya}


\begin{document}
\maketitle
\tableofcontents
\section{Definition}

\subsection{Emphasizing}

\begin{itemize}
    \item MUST
    \item OR
    \item CAN
\end{itemize}

\subsection{Notation and defintions}

\begin{itemize}
    \item case-senstive characters
    \item alpha numeric
    \item ERE: Extended Regular Expression
\end{itemize}

\section{Extended Regular Expressions}
This section describe extended regular expressions use by the lexer.
The shortcuts section describes simple ERE that are used to write
the advanced ERE.
\subsection{Shortcuts}

\begin{enumerate}
    \item \texttt{AlphaUpperCase = [A-Z]} : Match all uppercase letters
    \item \texttt{AlphaLowerCase = [a-z]} : Match all lowercase letters
    \item \texttt{Alpha = \{AlphaUpperCase\}|\{AlphaLowerCase\}} :
    Match alphabet case-sensitive characters
    \item \texttt{Numeric = [0-9]} : Match digit characters
    \item \texttt{AlphaNumeric = \{Alpha\}|\{Numeric\}} :
    Match alphabetic \textbf{OR} digit characters
\end{enumerate}

\subsection{Advanced}
\label{advanced-ere}
\begin{enumerate}
    \item \texttt{Number = ([1-9]{Numeric}*)|0} :
    Match all numbers that \textbf{MUST} start with a non-zero digit and follow
    by 0 or more digits (first RE),
    \textbf{OR} match only zero digit (second RE). This RE correspond to
    the [Number] lexical unit.
    \item \texttt{VarName = {Alpha}{AlphaNumeric}*}
    Match identifiers. Identifiers \textbf{MUST} starts with a alphabetic
    character and \textbf{CAN} be followed by 0 or more digits \textbf{OR}
    alphabetic characters.
    Correspond to the [VarName] lexical unit.
    \item \texttt{Blank = \\s+}
\end{enumerate}

\subsection{Keywords}

\label{ere-keywords}

All the following keyword are matching \textit{themself} directly \textit{i.e.}
return the corresponding symbol and lexical unit
(see section \ref{impl-keywords}):\\

\begin{tabular}{|c|c|c|c|c|}
    \hline
    ; & := & ( & )  & + \\
    \hline
    - & *  & / & if & then \\
    \hline
    endif & else & while & for & from \\
    \hline
    by & to & do & done & note \\
    \hline
    and & or & = & $>$= & $>$ \\
    \hline
    $<$= & $<$ & $<>$ & print & read \\
    \hline
    begin & end & & &  \\
    \hline
\end{tabular}



\section{Implementation}

\subsection{Code structure}

\paragraph{Files}

Our implementation is contained in two files: \texttt{LexicalAnalyzer.flex},
contains the ERE that analyse the input sources and \texttt{ImpCompilo.java}
that contains the Java source code, used in the regular Expressions
matching actions.


\paragraph{Code flexibility}

To allow a better code flexibility, the JFlex generated class will
\texttt{extends} \texttt{ImpCompilo} class. This allow to develop the
compilator directly from a Java source class, instead of putting the
ERE and the logical code inside the .flex file. The generated class is named
\texttt{Main.java}, which should be used to run the scanner.

\subsection{Keywords}

\label{impl-keywords}

\paragraph{}

This section describe the states implemented in our
lexical analyzer and the corresponding ERE used.

\paragraph{}

One state is enough (necessary) to return the IMP language tokens.
The state \textbf{YYINITIAL} (the default inclusive state) is used to match
all the keywords listed in section \ref{ere-keywords}. For each keyword
the action is running the method \texttt{ImpCompilo.symbol(LexicalUnit)}.
This method runs the following instruction:
\begin{enumerate}
    \item if LexicalUnit is VarName: add it to \texttt{identifiers} dictionnary
    \item Add the symbol to \texttt{symbols}
    \item Output the symbol using the provided \texttt{toString} method.
\end{enumerate}
\paragraph{Example}

For the keyword \texttt{if}, the corresping ERE line in YYINITIAL is:

\begin{lstlisting}[frame=single]
"if"             {return symbol(LexicalUnit.IF);}
\end{lstlisting}

\paragraph{}
[VarName] and [Number] lexical units are also handled in \textbf{YYINITIAL}.
The only difference is that the right-side of the line code is not a keyword
but the correspding ERE defined in section \ref{advanced-ere}.

\subsection{Blank characters}

Blank characters, space, new line and tabs characters,
are ignored by the scanner. It is
done by matching space \textit{i.e.} the ERE \texttt{\s+}, which match
1 or more blank character, to an empty action. We have in YYINITIAL:
\begin{lstlisting}[frame=single]
{Blank}        {}
\end{lstlisting}

\subsection{Unknown token}

If some characters don't match any of the ERE in YYINITIAL, the scanner
will output:

\begin{lstlisting}[frame=single]
Unknown token: '<text>'
\end{lstlisting}

Note that this does not append in the COMMENT state (section \ref{comment}),
since everything is ignored.

\subsection{Comments}
\label{comment}

\paragraph{}

Comments can only be represented by an enclosed text:
 \texttt{(* \textit{Comments content} *)}.

Therefore the solution provide to ignore the comments is the following:
\begin{itemize}

\item In YYINITIAL and comment is opened, i.e. matches \texttt{(*},
change state to COMMENT

\item In COMMENT, Ignore all characters
(including blank characters) except the ending comment
characters \texttt{*)}.
If these characters are matched change state to YYINITIAL.

\end{itemize}

This process will ignore all characters in enclosed in comments.

\subsubsection{Forbidden behaviours}
\label{comment_forbidden}
\paragraph{}
There are two forbidden behaviours of comment detection that can be highlighted:

\begin{enumerate}
    \item A comment is opened but not closed.
    \item A closed comment is detected, but no opening precede it.
\end{enumerate}

The behaviour number 1 will ignore every characters until the EOF, since
the state will change to COMMENT.
\paragraph{}

The behaviour number 2 is in state YYINITIAL,
which means that the \textit{closed}
comment characters \texttt{*)} will match
the TIMES and LPAREN \textt{LexicalUnit},
because the closed comment characters are only defined in COMMENT state.
\paragraph{}

With our implementation the nested comments, that are forbidden, will
raise a syntax error, when detected in the parser. Because with
\texttt{(* (* *) *)}, the second comment opening will be ignored in the
COMMENT state, the first closed comment characters will close the first comment
opening. The last closed comment characters is left as if we were in
behaviour number 2.

\subsubsection{Nested comments (Bonus)}

\paragraph{}
If we need to handle nested comments, an easy implementation is to use a
counter that will count how many comments are opened, therefore how many
comments still need to be closed. The process is the following:
\begin{enumerate}
    \item in YYINITIAL, if comment open: init counter to 1 and change state
    to COMMENT.
    \item in COMMENT, if comment open: increment the counter.
    \item in COMMENT, if comment close: decrement the counter, and
    if the counter is equal to 0, change state to YYINITIAL.
\end{enumerate}

Here is an implementation of the proposed solution (in pseudocode): \\
\begin{lstlisting}[frame=single]
// Lexer
<YYINITIAL> {
    ...
    "(*"    {initCommentState();}
    ...
}

<COMMENT> {
    "(*"    {openComment();}
    "*)"    {closeComment();}
    .|{Blank}   {} // Ignore everything else
}

// Code

initCommentState(){
    commentCounter = 1;
    changeState(COMMENT);
}

openComment(){
    commentCounter++;
}

closeComment(){
    commentCounter--;
    if (commentCounter == 0) // If all closed, scan
        changeState(YYINITIAL);
}

\end{lstlisting}

\paragraph{}
For the example given in section \ref{comment_forbidden}, if we use the
solution proposed above, no error will be detected, and the nested
comments will be ignored.

\section{HowTo}

\subsection{Files}

The executable jar is \textbf{dist/imp-compilo.jar}.
The source files are in \textbf{more/src}. It contains the following files:

\begin{itemize}
    \item LexicalUnit.java: provided class.
    \item Symbol.java: provided class.
    \item ImpCompilo.java: the class that the lexer extends, containing the
    source code used in the lexer.
    \item LexicalAnalyzer.jflex: the lexical analyzer that generates the
    Main.java class.
\end{itemize}

\subsection{Build and JavaDoc}

## How To

Run scanner
java -jar dist/imp-compilo.jar <input>
or
gradle scan -Pinput=<input>

Generate **more/src/Main.java** from more/src/LexicalAnalyzer.flex
```bash
gradle generateMain
```
Generate jar **dist/imp-compilo.jar**
```bash
gradle generateJar
```

Generate JavaDoc in **doc/javadoc**
```bash
gradle generateDoc
```


The JavaDoc is available at doc/javadoc/ImpCompilo.html

\end{document}
